---
stitle: "Capstone"
author: "Klaas Berbee & Thierry Ligeon"
date: "25-10-2017"
header-includes: \usepackage{hyperref,pdfpages,graphicx}
output: 
  pdf_document:
    number_sections: true
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include_Packages, echo=FALSE, message=FALSE}
if (!require("dplyr")) install.packages("dplyr")
if (!require("RMySQL")) install.packages("RMySQL")
if (!require("Amelia")) install.packages("Amelia")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("lubridate")) install.packages("lubridate")
if (!require("gridExtra")) install.packages("gridExtra")
if (!require("Lahman")) install.packages("Lahman")
if (!require("GGally")) install.packages("GGally")
library(dplyr)
library(RMySQL)
library(Amelia)
library(ggplot2)
library(lubridate)
library(gridExtra)
library(Lahman)
library(GGally)
```

\begin{titlepage}
\centering
	\includegraphics[width=0.15\textwidth]{intro}\par\vspace{1cm}
	{\scshape\LARGE Hogeschool van Amsterdam \par}
	\vspace{1cm}
	{\scshape\Large Capstone Big-Data in Urban Technology\par}
	\vspace{1.5cm}
	{\huge\bfseries Batting\par}
	\vspace{2cm}
	{\Large\itshape Klaas Berbee\par}
	{\Large\itshape Thierry Ligeon\par}
	\vfill
	supervised by\par
	Dr.~J.R. \textsc{Helmus}

	\vfill

% Bottom of the page
	{\large \today\par}


\end{titlepage}
\flushleft
\pagebreak
\tableofcontents
\pagebreak
\textit{This page is intentionally left blank.}
\pagebreak
\section{Capstone Batting}
\textit{Klaas Berbee \& Thierry Ligeon}

Voor de capstone van de minor Big-Data in Urban Technology aan de Hogeschool van Amsterdam moeten wij de Batting dataset gaan bestuderen. Zoals bij elke dataset moet er eerst een globaal beeld geschetst worden.

\subsection{Context van de dataset}

De Batting dataset bevat data over o.a.: teams, spelers en managers. Ook bevat de dataset informatie over hun salarissen en vaardigheden. Verder bevat deze dataset informatie over hoe de individuele wedstrijden verlopen zijn, welke activiteiten hierin zijn voorgekomen en door wie deze zijn uitgevoerd. 

Het doel is om deze dataset om te zetten naar nuttige informatie en hier vervolgens conclusies uit te kunnen trekken. Teams kunnen bijvoorbeeld een inzicht krijgen welke factoren een grote rol spelen in de prestaties van het team.


\subsubsection{Belanghebbende voor deze dataset}

\begin{description}

\item[Kansspel spelers] \hfill \\
Er kan een voordeel voor kansspelspelers ontstaan zodra zij bezitten over voorspelmodellen voor komende wedstrijden.

\item[Teamcoaches] \hfill \\
De coach kan uit de dataset de sterke en zwakke punten van de spelers inzien. Hierop kan hij zijn trainingen specificeren op bepaalde aspecten voor zijn spelers. Daarnaast kunnen de sterke en zwakke punten van de competitie bekeken worden om zo beter voor te kunnen bereiden op aankomende wedstrijden.

\item[Junior spelers] \hfill \\
Beginnende spelers kunnen hun idolen en vaardigheden vergelijken en bekijken bij welke club zij getraind hebben. Dit zou een aanleiding kunnen zijn om een club te kiezen

\item[Stadions] \hfill \\
Met deze dataset kan de hoeveelheid bezoekers voorspeld worden. Hierop kunnen prijzen, hoeveelheid beveiliging en promotie op worden aangepast.

\end{description}

\subsubsection{Hoe de dataset tot stand gekomen is}
Deze dataset is initieel opgezet door Sean Lahman in 1994. De dataset bevat data van 1871 tot 2016\cite{seanlahman}. Echter is deze dataset enkele keren herschreven naar een nieuw format. Daarnaast hebben ook meerdere mensen bijgedragen aan deze dataset. Hierdoor zouden er mogelijke imperfecties in de dataset kunnen zijn ontstaan.

\subsubsection{Hedendaagse problemen oplossen m.b.v. deze dataset}
De World Series MLB 2017 is in november afgesloten en gewonnen door de Houston Astros\cite{houstonastros}.  Er zouden modellen gemaakt kunnen worden op basis van de data uit deze dataset (tot en met 2012), en vergeleken kunnen worden met de uitslag van 2017. Hierop kan een deel van de prestatie van het model worden gebaseerd. Dit zou eveneens met de uitslagen van 2013 tot en met 2016 gedaan worden. Hieruit kan ook afgeleid worden of het model effectief blijft in de toekomst.

\subsection{Database Theorie}
\subsubsection{Entity-Relationship Diagram}
De batting dataset bestaat uit een relationele database. Hieruit kan een ERD worden opgesteld.
Enkele problemen die kunnen ontstaan bij het samenvoegen van tabellen:
\begin{itemize}
\item De begindatum van de variabelen is bij veel tabellen verschillend, bij het joinen van de ERD gaat sommige data hierdoor verloren.
\item Het overzicht na het mergen van deze ERD gaat verloren.
\end{itemize}

Door alle tabellen uit de database te bekijken zijn we tot onderstaand ERD gekomen:
\includegraphics{ERD}

\subsubsection{Datawarehouse}
\includegraphics{DWH}

\subsection{Extract Transform Load}
Na het opstellen van het ERD en het DWH kunnen we beginnen aan het ETL proces. Des te beter dit proces wordt uitgevoerd, des te makkelijker het daadwerkelijke data analyse proces wordt. De data is opgeslagen in een lokale MySQL Database.

\subsubsection{Data importeren via MySQL}
Via R-Studio en de package RMySQL kunnen wij een verbinding met een database opzetten. Dit doen wij op de hieronderstaande wijze, Vervolgens bekijken wij welke tabellen de MySQL dataset bevat.
```{r connecting_to_mySQL}
my_db <- dbConnect(MySQL(), 
                   user='klaasberbee', 
                   password='119OKVU', 
                   dbname='Batting', 
                   host='localhost')

print(dbListTables(my_db))
```
De database bestaat uit 27 verschillende tabellen, Dit zijn ook de tabellen die wij in onze ERD verwerkt hebben. Uit gemak importeren wij alle tabellen en besluiten wij later in de R-Studio omgeving welke tabellen wij zullen benutten.

```{r Loding all tables, results="hide"}
dbTables <- dbListTables(my_db)

allTables <-
  lapply(dbTables, function(table) {
    dbGetQuery(my_db, paste("select * from", table))
  })
names(allTables) <- paste("db", dbTables, sep = "_")
list2env(allTables, envir = .GlobalEnv)
```

Na het importeren hebben wij van onderstaande code gebruik gemaakt om de primary keys te kunnen bepalen voor het ERD

```{r welke column is de p key, results="hide"}
db_AllstarFull[(duplicated(db_AllstarFull[c("playerID","gameID")])
                 | duplicated(db_AllstarFull[c("playerID","gameID")], fromLast = TRUE)), ]
db_Appearances[(duplicated(db_Appearances[c("playerID","yearID","teamID")])
                 | duplicated(db_Appearances[c("playerID","yearID", "teamID")], fromLast = TRUE)), ]
db_AwardsManagers[(duplicated(db_AwardsManagers[c("playerID","awardID", "yearID")])
                 | duplicated(db_AwardsManagers[c("playerID","awardID", "yearID")], fromLast = TRUE)),]
db_AwardsPlayers[(duplicated(db_AwardsPlayers[c("playerID","awardID", "yearID", "lgID")])
                 | duplicated(db_AwardsPlayers[c("playerID","awardID", "yearID", "lgID")], fromLast = TRUE)),]
db_AwardsShareManagers[(duplicated(db_AwardsShareManagers[c("playerID", "yearID")])
                 | duplicated(db_AwardsShareManagers[c("playerID", "yearID")], fromLast = TRUE)), ]
db_AwardsSharePlayers[(duplicated(db_AwardsSharePlayers[c("playerID", "yearID", "awardID")])
                 | duplicated(db_AwardsSharePlayers[c("playerID", "yearID", "awardID")], fromLast = TRUE)),]
db_Batting[(duplicated(db_Batting[c("playerID", "yearID", "stint")])
                 | duplicated(db_Batting[c("playerID", "yearID", "stint")], fromLast = TRUE)), ]
db_BattingPost[(duplicated(db_BattingPost[c("playerID", "yearID", "round")])
                 | duplicated(db_BattingPost[c("playerID", "yearID", "round")], fromLast = TRUE)), ]
db_CollegePlaying[(duplicated(db_CollegePlaying[c("playerID", "yearID", "schoolID")])
                 | duplicated(db_CollegePlaying[c("playerID", "yearID", "schoolID")], fromLast = TRUE)),]
db_Fielding[(duplicated(db_Fielding[c("playerID", "yearID", "stint", "POS")])
                 | duplicated(db_Fielding[c("playerID", "yearID", "stint", "POS")], fromLast = TRUE)),]
db_FieldingOF[(duplicated(db_FieldingOF[c("playerID", "yearID", "stint")])
                 | duplicated(db_FieldingOF[c("playerID", "yearID", "stint")], fromLast = TRUE)),]
db_FieldingOFsplit[(duplicated(db_FieldingOFsplit[c("playerID", "yearID", "stint", "POS")])
                 | duplicated(db_FieldingOFsplit[c("playerID", "yearID", "stint", "POS")], fromLast = TRUE)),]
db_FieldingPost[(duplicated(db_FieldingPost[c("playerID", "yearID", "round", "POS")])
                 | duplicated(db_FieldingPost[c("playerID", "yearID", "round", "POS")], fromLast = TRUE)),]
db_HallOfFame[(duplicated(db_HallOfFame[c("playerID", "yearid", "votedBy")])
                 | duplicated(db_HallOfFame[c("playerID", "yearid", "votedBy")], fromLast = TRUE)),]
db_HomeGames[(duplicated(db_HomeGames[c("year.key", "team.key", "park.key")])
                 | duplicated(db_HomeGames[c("year.key", "team.key", "park.key")], fromLast = TRUE)),]
db_Managers[(duplicated(db_Managers[c("playerID", "yearID", "inseason")])
                 | duplicated(db_Managers[c("playerID", "yearID", "inseason")], fromLast = TRUE)),]
db_ManagersHalf[(duplicated(db_ManagersHalf[c("playerID","yearID","half")])
                 | duplicated(db_ManagersHalf[c("playerID","yearID","half")], fromLast = TRUE)), ]
db_Master[(duplicated(db_Master["playerID"])
                 | duplicated(db_Master["playerID"], fromLast = TRUE)), ]
db_Parks[(duplicated(db_Parks["park.key"])
                 | duplicated(db_Parks["park.key"], fromLast = TRUE)), ]
db_Pitching[(duplicated(db_Pitching[c("playerID", "yearID", "stint")])
                 | duplicated(db_Pitching[c("playerID", "yearID", "stint")], fromLast = TRUE)), ]
db_PitchingPost[(duplicated(db_PitchingPost[c("playerID", "yearID", "round")])
                 | duplicated(db_PitchingPost[c("playerID", "yearID", "round")], fromLast = TRUE)), ]
db_Salaries[(duplicated(db_Salaries[c("playerID", "yearID", "teamID")])
                 | duplicated(db_Salaries[c("playerID", "yearID", "teamID")], fromLast = TRUE)), ]
db_Schools[(duplicated(db_Salaries["schoolID", ])
                 | duplicated(db_Salaries["schoolID", ], fromLast = TRUE)), ]
db_SeriesPost[(duplicated(db_SeriesPost[c("yearID", "round")])
                 | duplicated(db_SeriesPost[c("yearID", "round")], fromLast = TRUE)), ]
db_Teams[(duplicated(db_Teams[c("yearID", "teamID")])
                 | duplicated(db_Teams[c("yearID", "teamID")], fromLast = TRUE)), ]
db_TeamsFranchises[(duplicated(db_TeamsFranchises[c("franchID")])
                 | duplicated(db_TeamsFranchises[c("franchID")], fromLast = TRUE)), ]
db_TeamsHalf[(duplicated(db_TeamsHalf[c("teamID", "Half")])
                 | duplicated(db_TeamsHalf[c("teamID", "Half")], fromLast = TRUE)), ]
glimpse(db_AllstarFull)

db_Managers %>%
  filter(yearID == 1892)

db_ManagersHalf %>%
  filter(yearID == 1892)
nrow(db_AwardsManagers)
```


\subsubsection{Data transformeren}
De opdracht meende dat sommige tabellen variabelen bevatte met het verkeerde type. Ons ERD gaf dit ook al aan. Om dit te verifiëren voeren wij een 0e functie uit op het Pitching tabel.

```{r glimpsing,fig.width=12, fig.height=8}
glimpse(db_Pitching)
```

Zoals hierboven staat, bevat dit tabel zowel variabelen van de classes Integers, Doubles en Characters. Echter is de class van teamID en lgID nog incorrect, dit zouden een factoren moeten zijn. Daarnaast zijn ook enkele Integer kolommen opgevat als Characters. Dit betekend dat dit in meerdere tabellen een probleem kan zijn. Kijkend naar de vragen in de opdrachtbeschrijving hebben we besloten om vanaf nu gebruik te maken van de volgende tabellen:
\begin{itemize}
\item Pitching
\item Batting
\item Fielding
\item Master
\item Teams
\item Salaries
\end{itemize}
\pagebreak
```{r Viewing table classes , results="hide"}
glimpse(db_Batting)
glimpse(db_Fielding)
glimpse(db_Master)
glimpse(db_Teams)
glimpse(db_Salaries)
```

Aan de hand van deze 0e orde functie resultaten passen wij ook de rest van de incorrecte classes aan.

```{r Transforming table classes, results="hide"}
#db_Pitching

db_Pitching$teamID = as.factor(db_Pitching$teamID)
db_Pitching$lgID = as.factor(db_Pitching$lgID)
db_Pitching$BAOpp = as.double(db_Pitching$BAOpp)
db_Pitching$IBB = as.integer(db_Pitching$IBB)
db_Pitching$WP = as.integer(db_Pitching$WP)
db_Pitching$HBP = as.integer(db_Pitching$HBP)
db_Pitching$BFP = as.integer(db_Pitching$BFP)
db_Pitching$GF = as.integer(db_Pitching$GF)
db_Pitching$SH = as.integer(db_Pitching$SH)
db_Pitching$SF = as.integer(db_Pitching$SF)
db_Pitching$GIDP = as.integer(db_Pitching$GIDP)

#db_Batting
db_Batting$teamID = as.factor(db_Batting$teamID)
db_Batting$lgID = as.factor(db_Batting$lgID)
db_Batting$IBB = as.integer(db_Batting$IBB)
db_Batting$HBP = as.integer(db_Batting$HBP)
db_Batting$SH = as.integer(db_Batting$SH)
db_Batting$SF = as.integer(db_Batting$SF)
db_Batting$GIDP = as.integer(db_Batting$GIDP)

db_Fielding$teamID = as.factor(db_Fielding$teamID)
db_Fielding$lgID = as.factor(db_Fielding$lgID)
db_Fielding$POS = as.factor(db_Fielding$POS)
db_Fielding$GS = as.integer(db_Fielding$GS)
db_Fielding$InnOuts = as.integer(db_Fielding$InnOuts)
db_Fielding$PB = as.integer(db_Fielding$PB)
db_Fielding$WP = as.integer(db_Fielding$WP)
db_Fielding$SB = as.integer(db_Fielding$SB)
db_Fielding$CS = as.integer(db_Fielding$CS)
db_Fielding$ZR = as.integer(db_Fielding$ZR)

db_Master$birthCountry = as.factor(db_Master$birthCountry)
db_Master$birthState = as.factor(db_Master$birthState)
db_Master$deathYear = as.integer(db_Master$deathYear)
db_Master$deathMonth = as.integer(db_Master$deathMonth)
db_Master$deathDay = as.integer(db_Master$deathDay)
db_Master$deathCountry = as.factor(db_Master$deathCountry)
db_Master$deathState = as.factor(db_Master$deathState)
db_Master$bats = as.factor(db_Master$bats)
db_Master$throws = as.factor(db_Master$throws)

db_Teams$teamID = as.factor(db_Teams$teamID)
db_Teams$lgID = as.factor(db_Teams$lgID)
db_Teams$franchID = as.factor(db_Teams$franchID)
db_Teams$divID = as.factor(db_Teams$divID)
db_Teams$Ghome = as.integer(db_Teams$Ghome)
db_Teams$DivWin = as.factor(db_Teams$DivWin)
db_Teams$WCWin = as.factor(db_Teams$WCWin)
db_Teams$LgWin = as.factor(db_Teams$LgWin)
db_Teams$WSWin = as.factor(db_Teams$WSWin)
db_Teams$CS = as.integer(db_Teams$CS)
db_Teams$HBP = as.integer(db_Teams$HBP)
db_Teams$SF = as.integer(db_Teams$SF)
db_Teams$DP = as.integer(db_Teams$DP)
db_Teams$attendance = as.integer(db_Teams$attendance)
db_Teams$teamIDBR = as.factor(db_Teams$teamIDBR)
db_Teams$teamIDlahman45 = as.factor(db_Teams$teamIDlahman45)
db_Teams$teamIDretro = as.factor(db_Teams$teamIDretro)
setnames(data_table, "'2B'", "X2B")
setnames(data_table, "'3B'", "X3B")
names(db_Teams)[names(db_Teams) == "2B"] <- "X2B"
names(db_Teams)[names(db_Teams) == "3B"] <- "X3B"


db_Salaries$teamID = as.factor(db_Salaries$teamID)
db_Salaries$lgID = as.factor(db_Salaries$lgID)
```
De ontbrekende variabelen worden nu ook nog niet als een N/A beschouwd. Dit lossen we op door de hieronderstaande code.
```{r Define NA}
db_Pitching[db_Pitching == ""] = NA
db_Batting[db_Batting == ""] = NA
db_Fielding[db_Fielding == ""] = NA
db_Master[db_Master == ""] = NA
db_Teams[db_Teams == ""] = NA
db_Salaries[db_Salaries == ""] = NA
```

Na het correct indelen van de classes van elke variabelen en het correct beschouwen van de NA's kan in het Master tabel sommige datums beter ingedeeld worden. Dit bereiken wij door de onderstaande code.
```{r Dates fixing, results="hide"}
db_Master$birthDate = ymd(paste(db_Master$birthYear,db_Master$birthMonth,db_Master$birthDay,sep = "-"))
db_Master$deathDate = ymd(paste(db_Master$deathYear,db_Master$deathMonth,db_Master$deathDay,sep = "-"))
db_Master$debut = as.Date(db_Master$debut, format="%Y-%m-%d")
db_Master$finalGame = as.Date(db_Master$finalGame, format="%Y-%m-%d")
```

Hierna zouden wij de kolomnamen kunnen aanpassen. Echter hebben wij besloten om dit niet te doen en het tabel van Sean Lahman ernaast te houden\cite{seanlahman}. Dit vanwege in ons opzicht de snellere workflow en overzichtelijkere code.

Het loading proces hoeven wij vervolgens niet meer te doen aangezien wij de data zullen analyseren in dezelfde R-Studio omgeving.

\subsection{Data Exploreren}
\subsubsection{Missende Data}
Om te beginnen met het data exploratie proces moeten wij een tabel gebruiken dat verschillende klassen variabele bevat. Hier moeten we vervolgens de summary functie op uit voeren (1e orde functie).
Als voorbeeld nemen wij het tabel Pitching.

```{r Summary on table}
summary(db_Pitching)
```

Vervolgens kijken wij van de Pitching en Fielding tabellen naar de ontbrekende data met behulp van een missing map.
```{r Create missingmap from Pitching}
missmap(db_Pitching, col=c("black", "grey"), y.labels=NULL, y.at = NULL,legend=FALSE, main="Missingness Map of Pitching")

missmap(db_Fielding, col=c("black", "grey"), y.labels=NULL, y.at = NULL,legend=FALSE, main="Missingness Map of Fielding")
```

Uit de missing map van het Pitching tabel valt op te maken dat de kolommen: GIDP, SF, SH en IBB aanzienlijk minder datapunten bevatten. Deze kolommen bevatten eerst compleet geen data, en na een bepaalde tijd wel. Dit zou betekenen dat deze data pas opgeslagen werd vanaf een bepaalde datum. Bij het tabel BAOpp is dit echter anders. Hier ontbreekt redelijk wat data echter niet structureel. Ik zou niet kunnen verklaren waarom deze datapunten missen.

Bij het Fielding tabel mist er veel meer data. Voor de kolommen: ZR, WP, CS, SB en PB mist er erg onregelmatig data. Bij InnOuts is dit iets consistenter maar zit er ook nog steeds een apart gat. De missende waarden voor WP, CS, SB en PB zijn wel te verklaren. Deze variabelen gelden alleen voor Catchers, en aangezien het Fielding tabel spelers bevat voor alle posities zou het kunnen kloppen dat deze waarden alleen bekend zijn voor de catchers. de ZR (Zone Rating) kolom zou echter wel voor elke speler bekend moeten zijn, en niet voor enkele catchers. De aparte missende data bij InnsOuts heb ik echter ook geen verdere verklaring voor.

\subsubsection{Distributie}

We nemen als voorbeeld de kolommen G(Games) en HR(Homeruns) van het Pitching tabel en kijken naar de verdeling. 
```{r verdelingen}
aantalHR <- db_Pitching %>%
  group_by(HR)%>%
   summarise(observaties = n())

ggplot(aantalHR, aes(x=HR, y=observaties)) +
  geom_point(color = "gray30", size=1) +
  labs(y= "Aantal observaties", x = "Aantal homeruns per speler per jaar \n note: Wanneer een speler midden in zijn jaar van team veranderd, \n dan worden zijn aantal homeruns opnieuw geteld" , title = "Het aantal hoeveelheid homeruns worden er door een speler per jaar gemaakt")
```
Hier zien wij een positief scheve verdeling, dit houd in dat de grafiek asymmetrisch is omdat een natuurlijke limiet uitkomsten aan één kant voorkomt. De piek van de verdeling is uit het midden verplaatst in de richting van de limiet. Dit maakt een potentieel voorspelmodel relatief correct aangezien er niet 2 pieken in voorkomen.

```{r verdeling 1.1}
aantalG <- db_Pitching %>%
  group_by(G)%>%
   summarise(observaties = n())

ggplot(aantalG, aes(x=G, y=observaties)) +
  geom_point(color = "gray30", size=1) +
  labs(y= "Aantal observaties", x = "Aantal games per speler per jaar \n note: Wanneer een speler midden in zijn jaar van team veranderd, \n dan worden zijn aantal games opnieuw geteld" , title = "Het aantal hoeveelheid games die door een speler per jaar wordt gespeeld")

```
Het plot hier boven laat ene scheve bimodale verdeling zien, dit houd in dat er meerdere verdelingen gecombineerd zijn en dat de grafiek asymmetrisch is.  Dit maakt een potentiele voorspelmodel minder correct aangezien er zich meerdere pieken in bevinden.

time series:
```{r time series}
db_Salariestime <- db_Salaries %>%
filter(teamID == "BOS") %>%
  group_by(teamID)

db_Salariestime$yearID = strptime(db_Salariestime$yearID, "%Y")
db_Salariestime$yearID = as.character(db_Salariestime$yearID)

ggplot()+
  geom_line(data=db_Appearances, aes(yearID, G_all, color=as.factor(playerID)))
```

\subsubsection{Relaties}
De laatste stap van de data exploratie is het bekijken van mogelijke correlaties tussen verschillende variabelen. Dit kan erg gemakkelijk met behulp van de pairs functie.

```{r Pairs, eval=FALSE, include=FALSE}
panel.cor <- function(x, y, digits=2, prefix="", cex.cor) 
{
    usr <- par("usr"); on.exit(par(usr)) 
    par(usr = c(0, 1, 0, 1)) 
    r <- abs(cor(x, y)) 
    txt <- format(c(r, 0.123456789), digits=digits)[1] 
    txt <- paste(prefix, txt, sep="") 
    if(missing(cex.cor)) cex <- 0.8/strwidth(txt) 
 
    test <- cor.test(x,y) 
    text(0.5, 0.5, txt, cex = cex * r)
}

pairs(db_Batting[,c(6:13)],main="Pairs Batting Set",lower.panel=panel.smooth, upper.panel=panel.cor)
```
Uit de bovenstaande pairs resultaten valt op te maken dat er tussen de gekozen variabelen niet grote verbanden liggen. De grootste correlatie is tussen AB(At Bats) en H(Hits). 

Vervolgens herhalen wij deze functie voor het Pitching tabel
```{r pairs2, eval=FALSE, include=FALSE}
pairs(db_Pitching[,c(6:13)],lower.panel=panel.smooth, upper.panel=panel.cor, main="Pairs Pitching Set")
```
Wat er op valt aan het resultaat van de pairs functie over de Pitching set is dat IPouts een relatief grote correlatie met meerdere variabelen. Daarnaast is het apart dat er geen grote correlatie is tussen de hoeveelheid games, en games started of completed games. Bij deze laatste is de lijn zelfs plat.

\subsection{Data Managen}
Er zijn verschillende manieren om data te cleanen/cleansen. Kijkend naar de missing maps komt het vaak voor dat er in de vroegere jaren(1871-1955) datapunten ontbreken. Deze zouden ge-extrapoleerd kunnen worden met behulp van modellen. Echter hebben wij besloten om dit niet uit te voeren vanwege tijdsgebrek en met de dataset in deze staat te werken.

Wel moet de datum aangepast om aan de slag te kunnen met timeseries. We hebben besloten om 1 januari aan elke datum toe te voegen in verband met de class.
```{r year to date}
db_Salaries$yearID = as.Date(paste0(db_Salaries$yearID, '-01-01'))
```
\subsubsection{Transformeren tot timeseries}
We beginnen met het timeseries plotten van de totale salarissen van de teams. Volgens de NBA regels hoort een team uit 25 actieve spelers te bestaan\cite{minplayeramount}. Dit hebben wij ook als voorwarde meegenomen in het eerste plot. Echter is deze regel pas ingevoerd in 1914. Er zal dus wat data verloren. De hoeveelheid extra spelers die ook betaald worden dat een team bevat hebben wij hier even buiten beschouwing gelaten. Het doel is om een globaal inzicht te krijgen welke teams veel investeren in hun spelers. Wij verwachten dat er enkele uitschieters zullen zijn, Dit mede ook vanwege de hoeveelheid spelers, maar ook vanwege de meerprijs van \textit{betere} spelers.
```{r Timeseries 1}
db_Salaries %>% group_by(yearID, teamID) %>% summarise(total = sum(salary), total_players = n_distinct(playerID)) %>% filter(total_players>=25) %>% ggplot(.,aes(x=yearID, y=total, group=teamID)) + geom_line(aes(color=teamID)) + ggtitle("Total team salary per year") + xlab("Year") + ylab("Total Salary in USD")
```

Wat hier opvalt is dat de totale salarisuitgave van alle teams(ongeacht de hoeveelheid spelers) tot 1990 relatief dicht bij elkaar lag. Dit is in de loop van de jaren erg uit elkaar gegroeid. Ook zijn er teams die extreem veel meer uitgeven aan hun spelers. Deze zullen wij nader bekijken.

```{r Timeseries 1.1}
topTeams = db_Salaries %>% group_by(yearID, teamID) %>% summarise(total = sum(salary), total_players = n_distinct(playerID)) %>% filter(total_players>=25 & total >= 200000000) %>% pull(teamID) %>% unique()

db_Salaries %>% group_by(yearID, teamID) %>% summarise(total = sum(salary), total_players = n_distinct(playerID)) %>% filter(teamID %in% topTeams) %>% ggplot(.,aes(x=yearID, y=total, group=teamID)) + geom_point(aes(color=teamID)) + geom_line(aes(color=teamID)) + ggtitle("Total team salary per year once exceeded 200M USD") + xlab("Year") + ylab("Total Salary in USD") 
```
Hierboven staan de teams die ooit totaal meer dan 200 miljoen USD uitgegeven heeft aan hun spelers. Er is alleen maar salaris data van de LAD(Los Angeles Dodgers) en NYY(New York Yankees) bekend in 2016. Dit is erg vreemd en hebben wij geen directe verklaring voor aangezien de naamswijzijgingen van de teams niet in 2016 zijn gebeurd.

Vervolgens kijken wij naar het salaris van de top 5 spelers volgens een externe bron\cite
{top5}. Dit betekend niet dat zij de beste spelers zijn statistisch gezien. Maar dit geeft ons wel een referentiepunt. Eerst zullen we hun playerID moeten achterhalen.
```{r timeseries 2}
db_Master %>% filter(grepl('George Herman|Willie Mays|Henry Louis|Theodore Samuel|Tyrus Raymond', nameGiven)) %>% select(playerID, nameFirst, nameLast, nameGiven)
```
Zoals te zien is komen er meerere entries voor voor de top 5 spelers. Wel kan met combinatie voor/achternaam het juiste playerID gevonden worden.

```{r timeseries 2.1}
top5Players = c("aaronha1","aikenwi01","cobbty01","ruthba01","willite01")
db_Salaries %>% filter(playerID %in% top5Players)
```
En zoals we kunnen zien is van geen enkele van deze spelers hun salaris bekend. Hier houd dus dit spoor op. Ook hebben we besloten om dit toch te documenteren aangezien dit soort conclusies namelijk ook bij Big-Data naar voren komen. Dit zou waarschijnlijk eerder naarboven zijn gekomen als wij besloten hadden om alle tabellen te mergen. Toch hebben we besloten dit niet te doen vanwege de mogelijke onoverzichtelijkheden.

```{r maakt het salaris uit voor het winnen, eval=FALSE, include=FALSE}

db_Salariesteam <- db_Salaries %>%
group_by(yearID, teamID) %>%
summarise(gemsalptpj= mean(salary))

db_Gemsalarisperrank<- merge(x= db_Salariesteam, y= db_Teams , by.x = c("teamID", "yearID"), by.y = c("teamID", "yearID"), all.x = TRUE) %>%
select(yearID, teamID, lgID, Rank, gemsalptpj) %>%
  group_by(yearID, lgID, Rank) %>%
  filter(gemsalptpj == max(gemsalptpj)) %>%
  filter(lgID == "AL") %>%
  arrange(yearID, Rank)

ggplot(data=db_Gemsalarisperrank, aes(x=yearID, y=gemsalptpj, color=Rank)) +
geom_point()
```
Uit de bovenstaande plot blijkt dat er vroeger niet veel verschil was in het salaris. Daarbuiten blijkt dat het gemiddelde salaris van een team ook niet veel invloet had op de ranking. Nu, in de modernere wereld ziet u in de plot dat er een veel groter verschil is in het gemiddelde salaris per team. Daarnaast valt ook op dat de teams die een hoog gemiddeld salaris hebben over het algemeen hoger in de ranking eindigen.

```{r wat is het verschil tussen een goed en een minder goed team?}
db_Teamsx <- db_Teams %>%
  group_by(yearID, lgID, teamID) %>%
  summarise(WL = W / L)

db_Teamsy <-  merge(x= db_Teamsx, y= db_Teams , by.x = c("teamID", "lgID", "yearID"), by.y = c("teamID", "lgID", "yearID"), all.x = TRUE) %>%
  filter(WL >= 2 | WL <= 0.5) %>%
  filter(yearID >= 1970) %>%
  mutate(sucsesfullornot = ifelse(WL <= 1, "nietsuccesvol", "succesvol" ))

ggplot(data=db_Teamsy, aes(x=teamID, y=H, color=sucsesfullornot)) +
geom_point() +
 theme(axis.title.x=element_blank(),
             axis.text.x=element_blank(),
             axis.ticks.x=element_blank(),
             panel.grid.major = element_blank(),
             panel.grid.minor = element_blank(),
             panel.background = element_blank()) +
         labs(colour = "wel of geen sucsesvol team") +
         labs(y = "Hits")

ggplot(data=db_Teamsy, aes(x=teamID, y=HR, color=sucsesfullornot)) +
geom_point() +
 theme(axis.title.x=element_blank(),
             axis.text.x=element_blank(),
             axis.ticks.x=element_blank(),
             panel.grid.major = element_blank(),
             panel.grid.minor = element_blank(),
             panel.background = element_blank()) +
         labs(colour = "wel of geen sucsesvol team") +
         labs(y = "Homeruns")

ggplot(data=db_Teamsy, aes(x=teamID, y=SO, color=sucsesfullornot)) +
geom_point() +
 theme(axis.title.x=element_blank(),
             axis.text.x=element_blank(),
             axis.ticks.x=element_blank(),
             panel.grid.major = element_blank(),
             panel.grid.minor = element_blank(),
             panel.background = element_blank()) +
         labs(colour = "wel of geen sucsesvol team") +
         labs(y = "Strike Outs")

ggplot(data=db_Teamsy, aes(x=teamID, y=ERA, color=sucsesfullornot)) +
geom_point() +
 theme(axis.title.x=element_blank(),
             axis.text.x=element_blank(),
             axis.ticks.x=element_blank(),
             panel.grid.major = element_blank(),
             panel.grid.minor = element_blank(),
             panel.background = element_blank()) +
         labs(colour = "wel of geen sucsesvol team") +
         labs(y = "Earned Run Average")


```
Om te bepalen wat het grotste verschil is tussen een sucsesfull team en een niet succesfull team moet eerst bepaald worden wanneer een team sucsesfull is. Een team wordt in onze ogen pas succesfull geacht als een team een W/L ratio heeft van 2 of hoger en een niet sucsesfull bij een W/L van 0.5. Daarbuiten kijken we alleen naar de spelen van na 1970 zodat we alleen de data hebben van het modernere spel van nu. Uit de bovenstaande plots blijkt dat vooral de Hits en de Earned Run Average een groot verschil maakt tussen de succesvolle en niet succesvolle teams.

```{r top salaris, eval=FALSE, include=FALSE}
db_Salariesx <- db_Salaries %>%
  group_by(playerID) %>%
  add_count(playerID) %>%
  filter(n >= 3) %>%
  filter(yearID == min(yearID) | salary == max(salary))

db_Salariesy <- db_Salariesx %>%
  summarise(jaarmaxsalaris = max(yearID) - min(yearID))

db_Salariesxy <- db_Salaries %>%
  group_by(playerID) %>%
   add_count(playerID) %>%
  filter(n >= 3) %>%
  filter(yearID == min(yearID) | yearID == max(yearID)) %>%
  summarise(spelendaantaljaar = max(yearID) - min(yearID))
  
aantaljrmaxsalaris <- merge(db_Salariesy, db_Salariesxy, by = "playerID") %>%
transform(percentage = (jaarmaxsalaris / spelendaantaljaar) * 100)

Mode <- function(x) {
 ux <- unique(x)
 ux[which.max(tabulate(match(x, ux)))]
}

meestvoorkomende <- Mode(aantaljrmaxsalaris$percentage)
```

\subsection{Onderzoeksvragen}

\subsubsection{Team prestatie}

\subsubsection{Spelersprestatie}
\subsubsubsection{In welk jaar van je carriére verdien je het meest.}
De onderzoeksvraag \texit{After how many years are players at the top of their salary?} kan een vertekend beeld geven. Niet elke speler is gelijk, Speelt even veel jaar. en in dezelfde periode. Daarom kan er snel gemeten worden met twee maten. Daarom interperteren wij de vraag als volgt: \texit{In welk percentage van de loopbaan van een speler verdient hij/zij het meest} Om deze vraag te kunnen beantwoorden kan het helpen om een randvoorwaarde te stellen. Wij hebben deze bepaald op het volgende:
\begin{description}
\item[De speler moet minimaal 3 jaar actief zijn] Dit aangezien er ook een groot aantal spelers zijn die maar enkele jaren spelen. Dit is een te korte periode als een echte carriére te beschouwen en zal mogelijk resulteren in een ongeldige conclusie. Daarom zullen wij deze groep buiten beschouwing laten bij dit vraagstuk
\end{description}

- Uit het vraagstuk is gekomen dat de meeste players in hun laatste jaar hun maximum salaris verdienen. Dit zou er ook mee te maken kunnen hebben dat het salaris in het algemeen stijgd over de jaren heen(dit is te zien in de plot bij het eerste vraagstuk).

```{r player statistic based on batting}
salaries3 <- Salaries %>% select(playerID, yearID, teamID, salary)
masterInfo <- Master %>% select(playerID, birthYear, birthMonth, nameLast, nameFirst, bats, debut)

batting <- battingStats() %>%
  left_join(salaries3, by= c("playerID", "yearID", "teamID")) %>%
  left_join(masterInfo, by="playerID") %>%
  mutate(age = yearID - birthYear - 1L* (birthMonth >= 10)) %>%
  arrange(playerID, yearID, stint)
```

The Batting does not contain batting statistics derived from those present in the data.frame\cite{lahmanderived}. This
function calculates batting average (BA), plate appearances (PA), total bases (TB), slugging percentage
(SlugPct), on-base percentage (OBP), on-base percentage + slugging (OPS), and batting average
on balls in play (BABIP) for each record in a Batting-like data.frame

```{r What is the main difference between successful players and non successful players?}
batting1 <- batting %>%
  filter(SlugPct >= 0.8 | SlugPct <= 0.05) %>%
  filter(AB >= 25) %>%
   mutate(sucsesfullornot = ifelse(SlugPct <= 0.5, "nietsuccesvol", "succesvol" ))

battingsucces <- batting1 %>%
  filter(sucsesfullornot == "succesvol")
 
set.seed(2)
y <- battingsucces[sample(nrow(battingsucces), 1), ]

battingnotsucces <- batting1 %>%
  filter(sucsesfullornot == "nietsuccesvol")
 
set.seed(1)
x <- battingnotsucces[sample(nrow(battingnotsucces), 1), ]

battingwelofnietsucses<-rbind(x,y)

```
Er wordt alleen naar batters gekeken, het is namelijk moeilijk om een batters te vergelijken met bijvoorbeeld een pitcher. Een batter is in onze ogen goed wanneer zijn slugpct 0.8 of hoger is. Dit omdat er dan echt de beste van de beste uitgefilterd worden. Ook worden de spelers met een slugpct van 0.1 of kleiner, dit geeft echt de minst sucsesvolle spelers weer. Daarnaast moet een speler minimaal 5 keer At bat gekomen, dit omdat als een speler maar een paar keer at bat is gekomen en dan toevalig goed slaat kan dit een vertekent beeld geven. uit deze selectie wordt er een sucsesvole speler genomen en een niet succesvolle speler, deze worden vervolgens met elkaar vergeleken.

vergelijking moet nog gedaan worden!!!!!!!!!!!!!!!!!!!!!!!!!


```{r eerste vraag timeseries}
db_Teamstime<- db_Teams %>% select(yearID,teamID,G,HR,SV,X2B,X3B)%>% 
group_by(yearID)%>%
summarise(Gemmidelde_Saves_per_game= sum(SV,na.rm = TRUE)/sum(G,na.rm = TRUE),
          Gemmidelde_Homeruns_per_game = sum(HR, na.rm = TRUE)/sum(G, na.rm = TRUE),
          Gemmidelde_Doubles_per_game = sum(X2B, na.rm = TRUE)/sum(G, na.rm = TRUE),
          Gemmidelde_Triples_per_game = sum(X3B, na.rm = TRUE)/sum(G, na.rm = TRUE))

decompose(db_Teamstime, type = c("additive", "multiplicative"))

ggplot(data=db_Teamstime, aes(x=yearID)) +
geom_line(aes(y=Gemmidelde_Homeruns_per_game)) +
  geom_smooth(aes(y=Gemmidelde_Homeruns_per_game),method = "lm") +
geom_line(aes(y=Gemmidelde_Doubles_per_game)) +
  geom_smooth(aes(y=Gemmidelde_Doubles_per_game),method = "lm") +
geom_line(aes(y=Gemmidelde_Triples_per_game)) +
  geom_smooth(aes(y=Gemmidelde_Triples_per_game),method = "lm") +
geom_line(aes(y=Gemmidelde_Saves_per_game)) +
  geom_smooth(aes(y=Gemmidelde_Saves_per_game),method = "lm") 
```
Voordat er wordt bepaald of de leuke dingen nu zijn veranderd in vergelijking met vroeger moet er eerst worden bepaald wat de leuke gebeurtenissen zijn. in onze ogen is dit:
- Een home run
- Een save
- Een Triple
- Een duble

Uit de bovenstaande plot is op te maken dat

```{r cariere traject}

```

```{r veranderd de batting preformance over het seizoen}



```

```{r homegames beter?}
db_HomeGames1 <- db_HomeGames %>%
select(year.key,league.key, team.key, games) %>%
  group_by(year.key, league.key, team.key) %>%
  summarise(thuisgames = sum(games))

db_Gamehomegame <-  merge(x= db_Teams, y= db_HomeGames1 , by.x = c("teamID", "yearID", "lgID"), by.y = c("team.key", "year.key", "league.key"), all.x = TRUE) %>%
  arrange(yearID, teamID, lgID) %>%
  group_by(yearID, lgID, teamID) %>%
  mutate(uitgames = G - thuisgames) %>%
  select(yearID, lgID, teamID, Rank, thuisgames, uitgames, W, L) %>%
  filter(uitgames > 0)
  mutate(thuisuitratio = thuisgames / uitgames) %>%
  mutate(winverliesratio = W / L)

summary(db_Gamehomegame)

ggcorr(db_Gamehomegame[, 4:10], geom = "blank", label = TRUE, hjust = 0.75) +
  geom_point(size = 10, aes(color = coefficient > 0, alpha = abs(coefficient) > 0.5)) +
  scale_alpha_manual(values = c("TRUE" = 0.25, "FALSE" = 0)) +
  guides(color = FALSE, alpha = FALSE)
```
Om deze onderzoeksvraag te beandwoorden moet er eigelijk een dataset zijn waarin er per wedstrijd de stats van een game te zien is en wie er thuis speeld. Nu is alleen te zien hoeveel totale wedstrijden er zijn en hoeveel daarvan thuis zijn gespeeld.
\begin{thebibliography}{9}

\bibitem{seanlahman} 
Sean Lahman, Batting database explanation 2012,
\\\texttt{http://seanlahman.com/files/database/readme2012.txt}

\bibitem{houstonastros} 
AD: Houston Astros verslaan Los Angeles Dodgers, 2017, \\\texttt{url{https://www.ad.nl/andere-sporten/houston-astros-verslaan-los-angeles-dodgers-met-5-1~a6904dad}}

\bibitem{minplayeramount} 
Baseball Amanac: Baseball Rosters
\\\texttt{url{http://www.baseball-almanac.com/articles/baseball_rosters.html/}}

\bibitem{top5}
The Top Tens: Baseball Players 
\\\texttt{url{https://www.thetoptens.com/baseball-players/} 

\bibitem{lahmanderived}
Sean Lahman: Lahman
\\\texttt{url{https://cran.r-project.org/web/packages/Lahman/Lahman.pdf}}
\end{thebibliography}}


```{r maakt het salaris uit, eval=FALSE, include=FALSE}
#### dit stuk beantwoord de eerste vraag niet verkeerd opgevat miss later nog handig
db_AwardsSharePlayersMVP <- db_AwardsSharePlayers %>%
  filter(awardID == "MVP")

db_bestspelermetsalaris <- db_Salaries %>%
  group_by(yearID) %>%
  merge(x= db_AwardsSharePlayersMVP, y= db_Salaries, by.x = c("playerID", "yearID"), by.y = c("playerID", "yearID"), all.x = TRUE) %>%
  arrange(yearID) %>%
filter(!is.na(salary)) %>%
  group_by(yearID) %>%
  summarise(gemsalarisbestplayers = mean(salary))
  
db_gemsalaris <- db_Salaries %>%
  group_by(yearID) %>%
  summarise(gemsalpjr = mean(salary))

db_gemsalgoedenniet <- merge(x= db_bestspelermetsalaris, y= db_gemsalaris, by.x = "yearID", by.y = "yearID", all.x = TRUE)
#### dit stuk beantwoord de eerste vraag niet verkeerd opgevat miss later nog handig
```

```{r maakt het salaris uit, kennelijk overbodig... , eval=FALSE, include=FALSE}
#### dit stuk beantwoord de eerste vraag niet verkeerd opgevat miss later nog handig
db_AwardsSharePlayersMVP <- db_AwardsSharePlayers %>%
  filter(awardID == "MVP")

db_bestspelermetsalaris <- db_Salaries %>%
  group_by(yearID) %>%
  merge(x= db_AwardsSharePlayersMVP, y= db_Salaries, by.x = c("playerID", "yearID"), by.y = c("playerID", "yearID"), all.x = TRUE) %>%
  arrange(yearID) %>%
filter(!is.na(salary)) %>%
  group_by(yearID) %>%
  summarise(gemsalarisbestplayers = mean(salary))
  
db_gemsalaris <- db_Salaries %>%
  group_by(yearID) %>%
  summarise(gemsalpjr = mean(salary))

db_gemsalgoedenniet <- merge(x= db_bestspelermetsalaris, y= db_gemsalaris, by.x = "yearID", by.y = "yearID", all.x = TRUE)
#### dit stuk beantwoord de eerste vraag niet verkeerd opgevat miss later nog handig
```
---
stitle: "Capstone"
author: "Klaas Berbee & Thierry Ligeon"
date: "25-10-2017"
header-includes: \usepackage{hyperref,pdfpages,graphicx}
output: 
  pdf_document:
    number_sections: true
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include_Packages, echo=FALSE, message=FALSE}
if (!require("dplyr")) install.packages("dplyr")
if (!require("RMySQL")) install.packages("RMySQL")
if (!require("Amelia")) install.packages("Amelia")
if (!require("ggplot2")) install.packages("ggplot2")
library(dplyr)
library(RMySQL)
library(Amelia)
library(ggplot2)
```

\begin{titlepage}
\centering
	\includegraphics[width=0.15\textwidth]{intro}\par\vspace{1cm}
	{\scshape\LARGE Hogeschool van Amsterdam \par}
	\vspace{1cm}
	{\scshape\Large Capstone Big-Data in urban technology\par}
	\vspace{1.5cm}
	{\huge\bfseries Batting\par}
	\vspace{2cm}
	{\Large\itshape Klaas Berbee\par}
	{\Large\itshape Thierry Ligeon\par}
	\vfill
	supervised by\par
	Dr.~J.R. \textsc{Helmus}

	\vfill

% Bottom of the page
	{\large \today\par}


\end{titlepage}
\flushleft
\pagebreak
\tableofcontents
\pagebreak
\textit{This page is intentionally left blank.}
\pagebreak
\section{Capstone Batting}
\textit{Klaas Berbee \& Thierry Ligeon}

Voor de capstone van de minor Big-Data in Urban Technology aan de Hogeschool van Amsterdam moeten wij de Batting dataset gaan bestuderen. Zoals bij elke dataset moet er eerst een globaal beeld geschetst worden.

\subsection{Context van de dataset}

De Batting dataset bevat data over o.a.: teams, spelers en managers. Ook bevat de dataset informatie over hun salarissen en skills. Verder bevat deze dataset informatie over hoe de individuele wedstrijden verlopen zijn, welke activiteiten hierin zijn voorgekomen en door wie deze zijn uitgevoerd. 

Het doel is om deze dateset om te zetten naar nuttige informatie en hier vervolgens conclusies uit te kunnen trekken. Teams kunnen bijvoorbeeld een inzicht krijgen welke factoren een grote rol spelen in de prestaties van het team.


\subsubsection{Belanghebbende voor deze dataset}

\begin{description}

\item[Kansspel spelers] \hfill \\
Er kan een voordeel voor kansspelspelers ontstaan zodra zij bezitten over voorspelmodellen voor komende wedstrijden.

\item[Teamcoaches] \hfill \\
De coach kan uit de dataset de sterke en zwakke punten van de spelers inzien. Hierop kan hij zijn trainingen specificeren op bepaalde aspecten voor zijn spelers. Daarnaast kunnen de sterke en zwakke punten van de competitie bekeken worden om zo beter voor te kunnen bereiden oo aankomende wedstrijden.

\item[Junior spelers] \hfill \\
Beginnende spelers kunnen hun idolen en vaardigheden vergelijken en bekijken bij welke club zij getraind hebben. Dit zou een aanleiding kunnen zijn om een club te kiezen

\item[Stadions] \hfill \\
Met deze dataset kan de hoeveelheid bezoekers voorspeld worden. Hierop kunnen prijzen, hoeveelheid beveiliging en promotie op worden aangepast.

\end{description}

\subsubsection{Hoe de dataset tot stand gekomen is}
Deze dataset is initieel opgezet door Sean Lahman in 1994. De dataset bevat data van 1871 tot 2016\cite{seanlahman}. Echter is deze dataset enkele keren herschreven naar een nieuw format. Daarnaast hebben ook meerdere mensen bijgedragen aan deze dataset. Hierdoor zouden er mogelijke imperfecties in de dataset kunnen zijn onstaan.

\subsubsection{Hedendaagse problemen oplossen m.b.v. deze dataset}
De World Series MLB 2017 is in november afgesloten en gewonnen door de Houston Astros\cite{houstonastros}.  Er zouden modellen gemaakt kunnen worden op basis van de data uit deze dataset (tot en met 2012), en vergeleken kunnen worden met de uitslag van 2017. Hierop kan een deel van de prestatie van het model worden gebaseerd. Dit zou eveneens met de uitslagen van 2013 tot en met 2016 gedaan worden. Hieruit kan ook afgeleid worden of het model effectief blijft in de toekomst.

\subsection{Database Theorie}
\subsubsection{Entity-Relationship Diagram}
De batting dataset bestaat uit een relationele database. Hieruit kan een ERD worden opgesteld.
Enkele problemen die kunnen ontstaan bij het samenvoegen van tabellen:
?????????????????????
Door alle tabellen uit de database te bekijken zijn we tot onderstaand ERD gekomen:
	- De eene dataset gaat langer terug dan de ander, bij het joinen van de ERD gaat dan sommige data verloren.
  - Het overzicht na het mergen van deze ERD is direct weg

\subsubsection{Datawarehouse}

\subsection{Extract Transform Load}
Na het opstellen van het ERD en het DWH kunnen we beginnen aan het ETL proces. Des te beter dit proces wordt uitgevoerd, des te makkelijker het daadwerkelijke data analyse proces wordt. De data is opgeslagen in een lokale MySQL Database.

\subsubsection{Data importeren via MySQL}
Via R-Studio en de package RMySQL kunnen wij een verbinding met een database opzetten. Dit doen wij op de hieronderstaande wijze, Vervolgens bekijken wij welke tabellen de MySQL dataset bevat.
```{r connecting_to_mySQL}
my_db <- dbConnect(MySQL(), 
                   user='klaasberbee', 
                   password='119OKVU', 
                   dbname='Batting', 
                   host='localhost')

print(dbListTables(my_db))
```
De database bestaat uit 27 verschillende tabellen, Dit zijn ook de tabellen die wij in onze ERD verwerkt hebben. Uit gemak importeren wij alle tabellen en besluiten wij later in de R-Studio omgeving welke tabellen wij zullen benutten.

```{r Loding all tables, results="hide"}
dbTables <- dbListTables(my_db)

allTables <-
  lapply(dbTables, function(table) {
    dbGetQuery(my_db, paste("select * from", table))
  })
names(allTables) <- paste("db", dbTables, sep = "_")
list2env(allTables, envir = .GlobalEnv)
```

\subsubsection{Data transformeren}
De opdracht meende dat sommige tabellen variabelen bevatte met het verkeerde type. Ons ERD gaf dit ook al aan. Om dit te verifieren voeren wij een 0e functie uit op het Pitching tabel.

```{r glimpsing,fig.width=12, fig.height=8}
glimpse(db_Pitching)
```

Zoals hierboven staat, bevat dit tabel zowel variabelen van de classes Integers, Doubles en Characters. Echter is de class van teamID en lgID nog incorrect, dit zouden een factoren moeten zijn. Daarnaast zijn ook enkele Integer kolommen opgevat als Characters. Dit betekend dat dit in meerdere tabellen een probleem kan zijn. Kijkend naar de vragen in de opdrachtbeschrijving hebben we besloten om vanaf nu gebruik te maken van de volgende tabellen:
\begin{itemize}
\item Pitching
\item Batting
\item Fielding
\item Teams
\item Salaries
\end{itemize}
\pagebreak
```{r Viewing table classes , results="hide"}
glimpse(db_Batting)
glimpse(db_Fielding)
glimpse(db_Teams)
glimpse(db_Salaries)
```

Aan de hand van deze 0e orde functie resultaten passen wij ook de rest van de incorrete classes aan.


```{r Transforming table classes}
#db_Pitching

db_Pitching$teamID = as.factor(db_Pitching$teamID)
db_Pitching$lgID = as.factor(db_Pitching$lgID)
db_Pitching$BAOpp = as.double(db_Pitching$BAOpp)
db_Pitching$IBB = as.integer(db_Pitching$IBB)
db_Pitching$WP = as.integer(db_Pitching$WP)
db_Pitching$HBP = as.integer(db_Pitching$HBP)
db_Pitching$BFP = as.integer(db_Pitching$BFP)
db_Pitching$GF = as.integer(db_Pitching$GF)
db_Pitching$SH = as.integer(db_Pitching$SH)
db_Pitching$SF = as.integer(db_Pitching$SF)
db_Pitching$GIDP = as.integer(db_Pitching$GIDP)

#db_Batting
db_Batting$teamID = as.factor(db_Batting$teamID)
db_Batting$lgID = as.factor(db_Batting$lgID)
db_Batting$IBB = as.integer(db_Batting$IBB)
db_Batting$HBP = as.integer(db_Batting$HBP)
db_Batting$SH = as.integer(db_Batting$SH)
db_Batting$SF = as.integer(db_Batting$SF)
db_Batting$GIDP = as.integer(db_Batting$GIDP)

db_Fielding$teamID = as.factor(db_Fielding$teamID)
db_Fielding$lgID = as.factor(db_Fielding$lgID)
db_Fielding$POS = as.factor(db_Fielding$POS)
db_Fielding$GS = as.integer(db_Fielding$GS)
db_Fielding$InnOuts = as.integer(db_Fielding$InnOuts)
db_Fielding$PB = as.integer(db_Fielding$PB)
db_Fielding$WP = as.integer(db_Fielding$WP)
db_Fielding$SB = as.integer(db_Fielding$SB)
db_Fielding$CS = as.integer(db_Fielding$CS)
db_Fielding$ZR = as.integer(db_Fielding$ZR)

db_Teams$teamID = as.factor(db_Teams$teamID)
db_Teams$lgID = as.factor(db_Teams$lgID)
db_Teams$franchID = as.factor(db_Teams$franchID)
db_Teams$divID = as.factor(db_Teams$divID)
db_Teams$Ghome = as.integer(db_Teams$Ghome)
db_Teams$DivWin = as.factor(db_Teams$DivWin)
db_Teams$WCWin = as.factor(db_Teams$WCWin)
db_Teams$LgWin = as.factor(db_Teams$LgWin)
db_Teams$WSWin = as.factor(db_Teams$WSWin)
db_Teams$CS = as.integer(db_Teams$CS)
db_Teams$HBP = as.integer(db_Teams$HBP)
db_Teams$SF = as.integer(db_Teams$SF)
db_Teams$DP = as.integer(db_Teams$DP)
db_Teams$attendance = as.integer(db_Teams$attendance)
db_Teams$teamIDBR = as.factor(db_Teams$teamIDBR)
db_Teams$teamIDlahman45 = as.factor(db_Teams$teamIDlahman45)
db_Teams$teamIDretro = as.factor(db_Teams$teamIDretro)

db_Salaries$teamID = as.factor(db_Salaries$teamID)
db_Salaries$lgID = as.factor(db_Salaries$lgID)
```

De ontbrekende variabelen worden nu ook nog niet als een N/A beschouwd. Dit lossen we op door de hieronderstaande code.
```{r Define NA}
db_Pitching[db_Pitching == ""] = NA
db_Batting[db_Batting == ""] = NA
db_Fielding[db_Fielding == ""] = NA
db_Teams[db_Teams == ""] = NA
db_Salaries[db_Salaries == ""] = NA
```
Het loading proces hoeven wij vervolgens niet meer te doen aangezien wij de data zullen analyseren in dezelfde R-Studio omgeving.

\subsection{Data Exploreren}
\subsubsection{Missende Data}
Om te beginnen met het data exploratie proces moeten wij een tabel gebruiken dat verschillende klassen variabele bevat. Hier moeten we voervolgens de summary functie op uit voeren (1e orde functie).
Als voorbeeld nemen wij het tabel Pitching.

```{r Summary on table}
summary(db_Pitching)
```

Vervolgens kijken wij van de Pitching en Fielding tabellen naar de ontbrekende data met behulp van een missing map.
```{r Create missingmap from Pitching}
missmap(db_Pitching, col=c("black", "grey"), y.labels=NULL, y.at = NULL,legend=FALSE, main="Missingness Map of Pitching")

missmap(db_Fielding, col=c("black", "grey"), y.labels=NULL, y.at = NULL,legend=FALSE, main="Missingness Map of Fielding")


```
Uit de missing map van het pitching tabel valt op te maken dat de kolommen: GIDP, SF, SH en IBB aanzienlijk minder datapunten bevatten. Deze kolommen bevatten eerst compleet geen data, en na een bepaalde tijd wel. Dit zou betekenen dat deze data pas gelogd wert vanaf een bepaalde datum. Bij het tabel BAOpp is dit echter anders. Hier ontbreekt redelijk wat data echter niet structureel. Ik zou niet kunnen verklaren waarom deze datapunten missen.

Bij het Fielding tabel mist er veel meer data. Voor de colommen: ZR, WP, CS, SB en PB mist er erg onrgelematig data. Bij InnOuts is dit iets consistenter maar zit er ook nogsteeds een apart gat. De missende waarden voor WP, CS, SB en PB zijn wel te verklaren. Deze variabelen gelden alleen voor Catchers, en aangezien het Fielding tabel spelers bevat voor alle posities zou het kunnnen kloppen dat deze waarden alleen bekend zijn voor de catchers. de ZR (Zone Rating) kolom zou echter wel voor elke speler bekend moeten zijn, en niet voor enkele catchers. De aparte missende data bij InnsOuts heb ik echter ook geen verdere verklaring voor.

\subsubsection{Distributie}




\subsubsection{Relaties}
De laatste stap van de data exploratie is het bekijken van mogelijke correlaties tussen verschillende variabelen. Dit kan erg gemakkelijk met behulp van de pairs functie.

```{r Pairs}
panel.cor <- function(x, y, digits=2, prefix="", cex.cor) 
{
    usr <- par("usr"); on.exit(par(usr)) 
    par(usr = c(0, 1, 0, 1)) 
    r <- abs(cor(x, y)) 
    txt <- format(c(r, 0.123456789), digits=digits)[1] 
    txt <- paste(prefix, txt, sep="") 
    if(missing(cex.cor)) cex <- 0.8/strwidth(txt) 
 
    test <- cor.test(x,y) 
    # borrowed from printCoefmat
    Signif <- symnum(test$p.value, corr = FALSE, na = FALSE, 
                  cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                  symbols = c("***", "**", "*", ".", " ")) 
 
    text(0.5, 0.5, txt, cex = cex * r) 
    text(.8, .8, Signif, cex=cex, col=2) 
}

pairs(db_Batting[,c(6:13)],main="Pairs Batting Set",lower.panel=panel.smooth, upper.panel=panel.cor)
```
Uit de bovenstaande pairsresultaten valt op te maken dat er tussen de gekozen variabelen niet grote verbanden liggen. De grootste correlatie is tussen AB(At Bats) en H(Hits). 

Vervolgens herhalen wij deze functie voor het Pitching tabel
```{r pairs2}
pairs(db_Pitching[,c(6:13)],lower.panel=panel.smooth, upper.panel=panel.cor, main="Pairs Pitching Set")
```

Doormiddel van de onderstaande code kan er uitgezocht worden wat de Primary Keys zijn.

```{r welke column is de p key, echo=FALSE, results="hide"}
db_AllstarFull[(duplicated(db_AllstarFull[c("playerID","gameID")])
                 | duplicated(db_AllstarFull[c("playerID","gameID")], fromLast = TRUE)), ]
db_Appearances[(duplicated(db_Appearances[c("playerID","yearID","teamID")])
                 | duplicated(db_Appearances[c("playerID","yearID", "teamID")], fromLast = TRUE)), ]
db_AwardsManagers[(duplicated(db_AwardsManagers[c("playerID","awardID", "yearID")])
                 | duplicated(db_AwardsManagers[c("playerID","awardID", "yearID")], fromLast = TRUE)),]
db_AwardsPlayers[(duplicated(db_AwardsPlayers[c("playerID","awardID", "yearID", "lgID")])
                 | duplicated(db_AwardsPlayers[c("playerID","awardID", "yearID", "lgID")], fromLast = TRUE)),]
db_AwardsShareManagers[(duplicated(db_AwardsShareManagers[c("playerID", "yearID")])
                 | duplicated(db_AwardsShareManagers[c("playerID", "yearID")], fromLast = TRUE)), ]
db_AwardsSharePlayers[(duplicated(db_AwardsSharePlayers[c("playerID", "yearID", "awardID")])
                 | duplicated(db_AwardsSharePlayers[c("playerID", "yearID", "awardID")], fromLast = TRUE)),]
db_Batting[(duplicated(db_Batting[c("playerID", "yearID", "stint")])
                 | duplicated(db_Batting[c("playerID", "yearID", "stint")], fromLast = TRUE)), ]
db_BattingPost[(duplicated(db_BattingPost[c("playerID", "yearID", "round")])
                 | duplicated(db_BattingPost[c("playerID", "yearID", "round")], fromLast = TRUE)), ]
db_CollegePlaying[(duplicated(db_CollegePlaying[c("playerID", "yearID", "schoolID")])
                 | duplicated(db_CollegePlaying[c("playerID", "yearID", "schoolID")], fromLast = TRUE)),]
db_Fielding[(duplicated(db_Fielding[c("playerID", "yearID", "stint", "POS")])
                 | duplicated(db_Fielding[c("playerID", "yearID", "stint", "POS")], fromLast = TRUE)),]
db_FieldingOF[(duplicated(db_FieldingOF[c("playerID", "yearID", "stint")])
                 | duplicated(db_FieldingOF[c("playerID", "yearID", "stint")], fromLast = TRUE)),]
db_FieldingOFsplit[(duplicated(db_FieldingOFsplit[c("playerID", "yearID", "stint", "POS")])
                 | duplicated(db_FieldingOFsplit[c("playerID", "yearID", "stint", "POS")], fromLast = TRUE)),]
db_FieldingPost[(duplicated(db_FieldingPost[c("playerID", "yearID", "round", "POS")])
                 | duplicated(db_FieldingPost[c("playerID", "yearID", "round", "POS")], fromLast = TRUE)),]
db_HallOfFame[(duplicated(db_HallOfFame[c("playerID", "yearid", "votedBy")])
                 | duplicated(db_HallOfFame[c("playerID", "yearid", "votedBy")], fromLast = TRUE)),]
db_HomeGames[(duplicated(db_HomeGames[c("year.key", "team.key", "park.key")])
                 | duplicated(db_HomeGames[c("year.key", "team.key", "park.key")], fromLast = TRUE)),]
db_Managers[(duplicated(db_Managers[c("playerID", "yearID", "inseason")])
                 | duplicated(db_Managers[c("playerID", "yearID", "inseason")], fromLast = TRUE)),]
db_ManagersHalf[(duplicated(db_ManagersHalf[c("playerID","yearID","half")])
                 | duplicated(db_ManagersHalf[c("playerID","yearID","half")], fromLast = TRUE)), ]
db_Master[(duplicated(db_Master["playerID"])
                 | duplicated(db_Master["playerID"], fromLast = TRUE)), ]
db_Parks[(duplicated(db_Parks["park.key"])
                 | duplicated(db_Parks["park.key"], fromLast = TRUE)), ]
db_Pitching[(duplicated(db_Pitching[c("playerID", "yearID", "stint")])
                 | duplicated(db_Pitching[c("playerID", "yearID", "stint")], fromLast = TRUE)), ]
db_PitchingPost[(duplicated(db_PitchingPost[c("playerID", "yearID", "round")])
                 | duplicated(db_PitchingPost[c("playerID", "yearID", "round")], fromLast = TRUE)), ]
db_Salaries[(duplicated(db_Salaries[c("playerID", "yearID", "teamID")])
                 | duplicated(db_Salaries[c("playerID", "yearID", "teamID")], fromLast = TRUE)), ]
db_Schools[(duplicated(db_Salaries["schoolID", ])
                 | duplicated(db_Salaries["schoolID", ], fromLast = TRUE)), ]
db_SeriesPost[(duplicated(db_SeriesPost[c("yearID", "round")])
                 | duplicated(db_SeriesPost[c("yearID", "round")], fromLast = TRUE)), ]
db_Teams[(duplicated(db_Teams[c("yearID", "teamID")])
                 | duplicated(db_Teams[c("yearID", "teamID")], fromLast = TRUE)), ]
db_TeamsFranchises[(duplicated(db_TeamsFranchises[c("franchID")])
                 | duplicated(db_TeamsFranchises[c("franchID")], fromLast = TRUE)), ]
db_TeamsHalf[(duplicated(db_TeamsHalf[c("teamID", "Half")])
                 | duplicated(db_TeamsHalf[c("teamID", "Half")], fromLast = TRUE)), ]
glimpse(db_AllstarFull)

db_Managers %>%
  filter(yearID == 1892)

db_ManagersHalf %>%
  filter(yearID == 1892)
nrow(db_AwardsManagers)
```

de verdelingen
```{r verdelingen}
aantalHR <- db_Pitching %>%
  group_by(HR)%>%
   summarise(observaties = n())

ggplot(aantalHR, aes(x=HR, y=observaties)) +
  geom_point(color = "gray30", size=1) +
  labs(y= "Aantal observaties", x = "Aantal homeruns per speler per jaar \n note: Wanneer een speler midden in zijn jaar van team veranderd, \n dan worden zijn aantal homeruns opnieuw geteld" , title = "Het aantal hoeveelheid homeruns worden er door een speler per jaar gemaakt")

aantalG <- db_Pitching %>%
  group_by(G)%>%
   summarise(observaties = n())

ggplot(aantalG, aes(x=G, y=observaties)) +
  geom_point(color = "gray30", size=1) +
  labs(y= "Aantal observaties", x = "Aantal games per speler per jaar \n note: Wanneer een speler midden in zijn jaar van team veranderd, \n dan worden zijn aantal games opnieuw geteld" , title = "Het aantal hoeveelheid gamesdie door een speler per jaar wordt gespeeld")

```
De eerste plot is positief scheve verdeling, dit houd in dat de grafiek asymmetrisch is omdat een natuurlijke limiet uitkomsten aan één kant voorkomt. De piek van de verdeling is uit het midden verplaatst in de richting van de limiet. Dit maakt een potentiele voorspelmodel betrouwbaar omdat de plot exponenteel is.
De tweede plot is een scheve bimodale verdeling, dit houd in dat er meerdere verdelingen gecombineerd zijn en dat de grafiek asymmetrisch is.  Dit maakt een potentiele voorspelmodel onbetrouwbaar omdat de plot niet exponenteel is.

\begin{thebibliography}{9}

\bibitem{seanlahman} 
Sean Lahman, Batting database explanation 2012,
\\\texttt{http://seanlahman.com/files/database/readme2012.txt}

\bibitem{houstonastros}
AD: Houston Astros verslaan Los Angeles Dodgers, 2017,
\\\texttt{https://www.ad.nl/andere-sporten/houston-astros-verslaan-los-angeles-dodgers-met-5-1~a6904dad}
\end{thebibliography}
